// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

//TODO: Replace Dummy Values
#define DECEL_DIST .9

#include "JoystickDrive.h"

JoystickDrive::JoystickDrive() {
	// Use requires() here to declare subsystem dependencies
	// eg. requires(chassis);
	Requires(Robot::drive);
}

// Called just before this Command runs the first time
void JoystickDrive::Initialize() {
	m_decelActive = false;
	m_initialPower = 0;
}

// Called repeatedly when this Command is scheduled to run
void JoystickDrive::Execute() {
	if(Robot::oi->IsAutoRangeForwards()) // If the button to stop the correct distance from the wall is pressed			
	{ 
		// If we are not decelerating and we're within the distance to begin decelerating
		if(!m_decelActive && Robot::drive->GetDistanceLong() <= DECEL_DIST) {			
			m_initialPower = (Robot::oi->GetYLeft() + Robot::oi->GetYRight()) / 2; // Set initialPower to average of left and right powers
			m_decelActive = true;
		}
		
		// Capture initial power level
		/* Are we within some defined distance of stopping point? (900mm example)
		   In that case, that's the number of ticks that we have to go
		   If so, take initial power level and divide by percentage of remaining distance
		*/
	}
//	else if (Robot::oi->IsAutoRangeBackwards()) // If the other button to stop the correct distance from the wall is pressed
//	{
//		if (Robot::drive->GetDistanceShort() > MAX_DISTANCE_SHORT) 		// If we're too far away
//			Robot::drive->TankDrive(-.75, .75);							// Drive backwards
//		else if(Robot::drive->GetDistanceShort() < MIN_DISTANCE_SHORT) 	// If we're too close
//			Robot::drive->TankDrive(.75, -.75); 						// Drive forwards
//		else 															// We're within a good range
//			Robot::drive->TankDrive(0, 0); 								// Stop moving	
//	}
	else
	{
		Robot::drive->TankDrive(-Robot::oi->GetYRight(), Robot::oi->GetYLeft()); // Drive with the joystick values
	}	
}

// Make this return true when this Command no longer needs to run execute()
bool JoystickDrive::IsFinished() {
	return false;
}

// Called once after isFinished returns true
void JoystickDrive::End() {
	
}

// Called when another command which requires one or more of the same
// subsystems is scheduled to run
void JoystickDrive::Interrupted() {

}
