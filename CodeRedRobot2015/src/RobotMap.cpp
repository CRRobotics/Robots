// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "RobotMap.h"
#include "LiveWindow/LiveWindow.h"


// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION
CANTalon* RobotMap::drivelDrive = NULL;
CANTalon* RobotMap::driverDrive = NULL;
CANTalon* RobotMap::drivecDrive = NULL;
Solenoid* RobotMap::drivelowerWheel = NULL;
Ultrasonic* RobotMap::drivelSonic = NULL;
Ultrasonic* RobotMap::driverSonic = NULL;
AnalogInput* RobotMap::drivelIR = NULL;
AnalogInput* RobotMap::driverIR = NULL;
Talon* RobotMap::acquisitionlAcquisition = NULL;
Talon* RobotMap::acquisitionrAcquisition = NULL;
Solenoid* RobotMap::acquisitionacqArm = NULL;
DigitalInput* RobotMap::acquisitiontoteSensor = NULL;
CANTalon* RobotMap::toteStackertoteLift = NULL;
Solenoid* RobotMap::toteStackerbrake = NULL;
DigitalInput* RobotMap::toteStackertoteHome = NULL;
CANTalon* RobotMap::containerStackercontainerLift = NULL;
Solenoid* RobotMap::containerStackerclaw = NULL;
DigitalInput* RobotMap::containerStackercontainerHome = NULL;
AnalogInput* RobotMap::containerStackerclawIR = NULL;
Victor* RobotMap::wingswingRetracter = NULL;
DigitalInput* RobotMap::wingsleftLimit = NULL;
DigitalInput* RobotMap::wingsrightLimit = NULL;
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=ALLOCATION

void RobotMap::init() {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	LiveWindow* lw = LiveWindow::GetInstance();

	drivelDrive = new CANTalon(DRV_MTR_LEFT);
	drivelDrive->ConfigNeutralMode(CANTalon::NeutralMode::kNeutralMode_Brake);
	
	driverDrive = new CANTalon(DRV_MTR_RIGHT);
	driverDrive->ConfigNeutralMode(CANTalon::NeutralMode::kNeutralMode_Brake);
	
	drivecDrive = new CANTalon(DRV_MTR_CENTER);
	drivecDrive->ConfigNeutralMode(CANTalon::NeutralMode::kNeutralMode_Brake);
	
	drivelowerWheel = new Solenoid(DRV_SOL_CNTR_SUSP);
	lw->AddActuator("Drive", "lowerWheel", drivelowerWheel);
	
	drivelSonic = new Ultrasonic(DRV_ULT_LEFTD);
	lw->AddSensor("Drive", "lSonic", drivelSonic);
	
	driverSonic = new Ultrasonic(DRV_ULT_RIGHTD);
	lw->AddSensor("Drive", "rSonic", driverSonic);
	
	drivelIR = new AnalogInput(DRV_ANA_LEFT);
	lw->AddSensor("Drive", "lIR", drivelIR);
	
	driverIR = new AnalogInput(DRV_ANA_RIGHT);
	lw->AddSensor("Drive", "rIR", driverIR);
	
	acquisitionlAcquisition = new Talon(ACQ_MTR_LEFT);
	
	
	acquisitionrAcquisition = new Talon(ACQ_MTR_RIGHT);
	
	
	acquisitionacqArm = new Solenoid(ACQ_SOL_EXTEND);
	lw->AddActuator("Acquisition", "acqArm", acquisitionacqArm);
	
	acquisitiontoteSensor = new DigitalInput(ACQ_DIN_TOTE_SENSE);
	lw->AddSensor("Acquisition", "toteSense", acquisitiontoteSensor);

	toteStackertoteLift = new CANTalon(TST_MTR_LIFT);
	double pToteLift = 0;
	double iToteLift = 0;
	double dToteLift = 0;
	int izone = 1024;
	double ramprate = 48;
	int profile = 1;
	
	toteStackertoteLift->SelectProfileSlot(profile);
	toteStackertoteLift->SetPID(pToteLift, iToteLift, dToteLift);
	toteStackertoteLift->SetIzone(izone);
	toteStackertoteLift->SetCloseLoopRampRate(ramprate);
	toteStackertoteLift->SetFeedbackDevice(CANTalon::QuadEncoder);
	
	toteStackerbrake = new Solenoid(TST_SOL_BRAKE);
	lw->AddActuator("ToteStacker", "brake", toteStackerbrake);
	
	toteStackertoteHome = new DigitalInput(TST_DIN_HOME);
	lw->AddSensor("ToteStacker", "toteHome", toteStackertoteHome);
	
	containerStackercontainerLift = new CANTalon(CST_MTR_LIFT);
	double pContainerLift = 0;
	double iContainerLift = 0;
	double dContainerLift = 0;
	
	containerStackercontainerLift->SelectProfileSlot(profile);
	containerStackercontainerLift->SetPID(pContainerLift, iContainerLift, dContainerLift);
	containerStackercontainerLift->SetIzone(izone);
	containerStackercontainerLift->SetCloseLoopRampRate(ramprate);
	containerStackercontainerLift->SetFeedbackDevice(CANTalon::QuadEncoder);
	
	containerStackerclaw = new Solenoid(CST_SOL_CLAW);
	lw->AddActuator("ContainerStacker", "claw", containerStackerclaw);
	

	containerStackercontainerHome = new DigitalInput(CST_DIN_HOME);
	lw->AddSensor("ContainerStacker", "containerHome", containerStackercontainerHome);
	
	containerStackerclawIR = new AnalogInput(CST_ANA_IR);
	lw->AddSensor("ContainerStacker", "clawIR", containerStackerclawIR);
	
	wingswingRetracter = new Victor(WNG_MTR_RET);
	
	wingsleftLimit = new DigitalInput(WNG_DIN_LEFT);
	lw->AddSensor("Wings", "leftLimit", wingsleftLimit);
	
	wingsrightLimit = new DigitalInput(WNG_DIN_RIGHT);
	lw->AddSensor("Wings", "rightLimit", wingsrightLimit);

	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
}
